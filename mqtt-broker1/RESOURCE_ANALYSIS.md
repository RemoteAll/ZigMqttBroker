# 资源消耗分析

## 关键发现：配置大不等于消耗大

当配置 100 万设备支持，但当前只有少数连接时，**资源消耗是按实际连接数计算的，不会浪费大量资源**。

## 1. 内存消耗详解

### 1.1 内存分配结构

```
┌─────────────────────────────────────────────────────────────┐
│ MQTT Broker 内存布局                                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ ┌─────────────────────┐                                    │
│ │ 固定开销 (~200 MB)  │                                    │
│ │ - 程序代码        │                                    │
│ │ - 全局数据结构    │                                    │
│ │ - 网络栈缓冲      │                                    │
│ └─────────────────────┘                                    │
│           ▼                                                 │
│ ┌─────────────────────────────────────────┐               │
│ │ 预热连接池 (MAX_CLIENTS_POOL)           │               │
│ │ = 100,000 × 11KB ≈ 1.1 GB              │               │
│ │ （大部分为 idle，实际使用部分才耗 CPU） │               │
│ └─────────────────────────────────────────┘               │
│           ▼                                                 │
│ ┌──────────────────────────────────────────────────────┐  │
│ │ 动态分配区 (实际连接数 × 单连接大小)                │  │
│ │                                                       │  │
│ │ 若当前连接数 < MAX_CLIENTS_POOL:                    │  │
│ │   → 使用预热池中的对象，无额外分配                  │  │
│ │                                                       │  │
│ │ 若当前连接数 >= MAX_CLIENTS_POOL:                   │  │
│ │   → 动态分配新对象                                  │  │
│ │                                                       │  │
│ │ 例：10K 连接 = 10,000 × 11 KB ≈ 110 MB             │  │
│ │ 例：100K 连接 = 100,000 × 11 KB ≈ 1.1 GB          │  │
│ │ 例：1M 连接 = 1,000,000 × 11 KB ≈ 11 GB            │  │
│ └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 预热机制说明

```zig
// config.zig
pub const MAX_CONNECTIONS = 1_000_000;    // 最大支持
pub const MAX_CLIENTS_POOL = 100_000;     // 预热 10%

// main_async.zig 启动时
try client_pool.preheat(config.MAX_CLIENTS_POOL);
// 立即分配 100,000 个连接对象，总计 ~1.1 GB

// 实际连接阶段
if (actual_connections < 100_000) {
    // ✅ 使用预热的对象，无额外分配
    // 这 1.1 GB 预热内存在这些连接上分摊
} else {
    // 当连接数超过预热大小后，才动态分配新对象
    // 所以大规模时才会触发额外分配
}
```

### 1.3 实际场景的内存使用

#### 场景 A：配置 1M，实际 10K 连接

```
总内存 = 固定(200MB) + 预热(1.1GB) + 实际(10K×11KB)
       = 200 + 1100 + 110 = 1410 MB ≈ 1.4 GB

其中：
- 固定部分：必须占用
- 预热部分：大部分处于 idle，但内存已分配
- 实际部分：真正被使用

预热效果：
✓ 当新连接到达时，无需分配，直接从池中取
✓ 连接断开时，归还到池中复用
✓ 减少频繁 malloc/free 的开销
```

#### 场景 B：配置 1M，实际 100K 连接

```
总内存 = 固定(200MB) + 预热(1.1GB) + 实际(100K×11KB)
       = 200 + 1100 + 1100 = 2400 MB ≈ 2.4 GB

此时：
- 预热的 100K 对象被完全使用
- 无需额外动态分配
- 内存利用率：100%
```

#### 场景 C：配置 1M，实际 1M 连接

```
总内存 = 固定(200MB) + 预热(1.1GB) + 实际(1M×11KB)
       = 200 + 1100 + 11000 = 12300 MB ≈ 12.3 GB

此时：
- 预热的 100K 对象全部用完
- 需要动态分配额外 900K 连接
- 动态部分：900K × 11KB ≈ 9.9 GB
- 总计：12.3 GB
```

## 2. CPU 消耗详解

### 2.1 关键改进：从轮询到阻塞

**之前的问题**（原始 `io.run()` 实现）：

```
时间轴：
T0ms:  io.run() (timeout=0) → 立即返回
       ↓
T1ms:  io.run() (timeout=0) → 立即返回
       ↓
T2ms:  io.run() (timeout=0) → 立即返回
       ↓
...
T99ms: io.run() (timeout=0) → 立即返回
       ↓
T100ms: 循环 → 回到 T0

结果：
- 每秒 1000 次 io.run() 调用（100ms × 10 次/秒）
- 每次调用都要经过系统调用开销
- CPU 持续忙碌，无法真正休眠
- 实际连接数多少无关，都要轮询
→ 3% CPU 占用（即使完全空闲！）
```

**改进后**（新 `io.run_for_ns(30s)` 实现）：

```
时间轴：
T0s:   io.run_for_ns(30秒) → 阻塞等待...
       ├─ 5s 统计定时器到期 → 唤醒处理
       └─ CPU 睡眠（0% 占用）
       ↓
T5s:   统计回调执行 → 立即回到等待
       ├─ io.run_for_ns(30秒) → 继续阻塞...
       └─ CPU 再次睡眠
       ↓
T10s:  统计回调执行...
       ↓
...

网络事件处理：
T3.2s: 客户端发送消息 → IOCP 立即唤醒
       ↓ < 1ms
T3.2s: 处理消息 → 发送响应
       ↓
T3.2s: 回到等待

结果：
- 每 5 秒 1 次唤醒（统计定时器），而不是每秒 10 次
- 网络事件立即处理（< 1ms，由 IOCP 保证）
- CPU 真正休眠当空闲时
→ < 0.5% CPU 占用（真正空闲！）
```

### 2.2 CPU 消耗量化对比

```
┌──────────────────────┬─────────────┬─────────────┬────────────┐
│ 指标                 │ 原方案      │ 改进方案    │ 改善比例   │
│                      │ (100ms轮询) │ (30s阻塞)   │            │
├──────────────────────┼─────────────┼─────────────┼────────────┤
│ 空闲期 CPU 占用      │ 3-5%        │ < 0.5%      │ 6-10x ✓    │
│ 每秒唤醒次数         │ 10          │ 0.2         │ 50x ✓      │
│ 系统调用开销         │ 高          │ 低          │ 大幅降低 ✓ │
│ 网络事件响应延迟     │ < 1ms       │ < 1ms       │ 相同 ✓     │
│ 定时器精度           │ 100ms       │ 5s          │ 无影响 ✓   │
└──────────────────────┴─────────────┴─────────────┴────────────┘

关键发现：
✓ 改进方案没有增加网络事件的响应延迟
✓ 只是减少了"无必要的唤醒"
✓ 空闲时 CPU 可以真正休眠
✓ 实际连接数无关，改进对所有场景都有效
```

### 2.3 CPU 使用场景分析

#### 小型部署（10K 连接，配置为 10K）

```
场景 A：完全空闲（0 消息/秒）
┌─────────────────────────────────────────┐
│ CPU 占用：< 0.5%                        │
│ - 主线程睡眠等待定时器                  │
│ - 5秒一次统计输出                       │
│ - 其余时间都在阻塞                      │
└─────────────────────────────────────────┘

场景 B：低负载（1,000 消息/秒）
┌─────────────────────────────────────────┐
│ CPU 占用：2-3%                          │
│ - 每条消息处理 ~ 100μs                  │
│ - 1000 msg/s × 100μs = 100ms/s         │
│ - 总 CPU = 100ms / 1000ms = 10% / 线程 │
│ - 单核 10% + 系统开销 → 总 2-3%         │
└─────────────────────────────────────────┘

场景 C：高负载（100,000 消息/秒）
┌─────────────────────────────────────────┐
│ CPU 占用：40-60%（8核机器）             │
│ - 每条消息处理 ~ 100μs                  │
│ - 100K msg/s × 100μs = 10s/s           │
│ - 需要 10 核并行处理                    │
│ - 8 核机器能处理 80K msg/s              │
│ - 此时 CPU 占用 ~ 80% / 8 核 = 10% ✓  │
│ - 实际占用 60-80%（考虑系统开销）      │
└─────────────────────────────────────────┘
```

## 3. 预热值选择指南

### 3.1 预热大小建议

```
┌──────────────────────────┬──────────────┬─────────────────┐
│ MAX_CONNECTIONS 设置     │ MAX_CLIENTS_ │ 预热内存占用    │
│                          │ POOL 推荐值  │                 │
├──────────────────────────┼──────────────┼─────────────────┤
│ 10,000                   │ 1,024        │ ~11 MB          │
│ 100,000                  │ 10,000       │ ~110 MB         │
│ 1,000,000                │ 100,000      │ ~1.1 GB         │
│ 10,000,000               │ 500,000      │ ~5.5 GB         │
└──────────────────────────┴──────────────┴─────────────────┘

选择原则：
1. 预热大小 = MAX_CONNECTIONS × 10-20%
   - 太小：频繁动态分配，降低性能
   - 太大：预热内存浪费

2. 预热时间：启动时一次分配
   - 启动可能需要 10-30 秒（取决于硬件）
   - 分配完成后性能稳定

3. 权衡考虑：
   - 内存充足：提高预热比例到 20-30%
   - 内存受限：降低预热比例到 5-10%
```

### 3.2 典型配置模板

```zig
// 开发环境
pub const MAX_CONNECTIONS = 100;
pub const MAX_CLIENTS_POOL = 10;
pub const IO_ENTRIES = 256;
pub const FORWARD_BATCH_SIZE = 100;

// 小型生产（< 10K）
pub const MAX_CONNECTIONS = 10_000;
pub const MAX_CLIENTS_POOL = 1_024;
pub const IO_ENTRIES = 256;
pub const FORWARD_BATCH_SIZE = 100;

// 中型生产（10K - 100K）
pub const MAX_CONNECTIONS = 100_000;
pub const MAX_CLIENTS_POOL = 10_000;
pub const IO_ENTRIES = 1_024;
pub const FORWARD_BATCH_SIZE = 1_000;

// 大型生产（100K - 1M）
pub const MAX_CONNECTIONS = 1_000_000;
pub const MAX_CLIENTS_POOL = 100_000;
pub const IO_ENTRIES = 4_095;
pub const FORWARD_BATCH_SIZE = 5_000;

// 超大型生产（1M+ 需要多机部署）
pub const MAX_CONNECTIONS = 10_000_000;
pub const MAX_CLIENTS_POOL = 500_000;
pub const IO_ENTRIES = 4_095;
pub const FORWARD_BATCH_SIZE = 10_000;
```

## 4. 成本效益表

### 4.1 不同规模的完整对比

```
┌────────────────────┬──────────┬──────────┬──────────┬──────────┐
│ 指标               │ 小型     │ 中型     │ 大型     │ 超大型   │
│                    │ (10K)    │ (100K)   │ (1M)     │ (10M)    │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 最大连接数         │ 10,000   │ 100,000  │ 1M       │ 10M      │
│ 预热大小           │ 1K       │ 10K      │ 100K     │ 500K     │
│ 预热内存           │ 11 MB    │ 110 MB   │ 1.1 GB   │ 5.5 GB   │
│ 固定开销           │ 200 MB   │ 200 MB   │ 200 MB   │ 200 MB   │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 实际 10K 连接时    │          │          │          │          │
│ - 总内存           │ 220 MB   │ 320 MB   │ 1.3 GB   │ 5.7 GB   │
│ - CPU (空闲)       │ < 0.5%   │ < 0.5%   │ < 0.5%   │ < 0.5%   │
│ - CPU (1K msg/s)   │ 2%       │ 2%       │ 2%       │ 2%       │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 实际 100K 连接时   │          │          │          │          │
│ - 总内存           │ N/A      │ 1.4 GB   │ 2.4 GB   │ 6.6 GB   │
│ - CPU (空闲)       │          │ < 0.5%   │ < 0.5%   │ < 0.5%   │
│ - CPU (10K msg/s)  │          │ 10%      │ 10%      │ 10%      │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 实际满载时         │          │          │          │          │
│ - 总内存           │ N/A      │ N/A      │ 13 GB    │ 115 GB   │
│ - CPU (占用)       │          │          │ 80%      │ 85%      │
│ - 吞吐量           │          │          │ 500K msg │ 5M msg   │
│                    │          │          │ /s       │ /s       │
├────────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 推荐硬件           │ 2C/4GB   │ 8C/16GB  │ 32C/64GB │ 64C/256GB│
│                    │ 千兆网   │ 千兆网   │ 万兆网   │ 多万兆   │
└────────────────────┴──────────┴──────────┴──────────┴──────────┘

关键结论：
✓ 预热内存随规模线性增长
✓ 固定开销保持不变（~200 MB）
✓ 空闲 CPU 占用与规模无关（< 0.5%）
✓ 活跃 CPU 占用与消息量相关，不随规模增加（同消息率同 CPU）
✓ 可以配置大、逐步增长，不浪费资源
```

## 5. 资源最优配置建议

### 5.1 保守配置（推荐新部署）

```zig
// 配置 2 倍预期最大连接数
// 这样可以在增长 2 倍后才需要重新配置

pub const MAX_CONNECTIONS = 20_000;      // 预期 10K 连接
pub const MAX_CLIENTS_POOL = 2_000;      // 预热 10%
pub const FORWARD_BATCH_SIZE = 500;      // 平衡的批处理
pub const DEFAULT_LOG_LEVEL = LogLevel.info;

// 内存占用：预热 ~20MB + 固定 ~200MB = ~220MB
// 增长空间：可增长到 20K 连接（2 倍）
```

### 5.2 激进配置（面向云平台弹性部署）

```zig
// 配置较小预热，利用云平台弹性扩展
// 需要时创建新实例而非单机扩容

pub const MAX_CONNECTIONS = 100_000;     // 单实例上限
pub const MAX_CLIENTS_POOL = 10_000;     // 预热 10%
pub const FORWARD_BATCH_SIZE = 1_000;    // 优化吞吐
pub const DEFAULT_LOG_LEVEL = LogLevel.info;

// 内存占用：预热 ~100MB + 固定 ~200MB = ~300MB
// 扩展方案：超过负荷时启动新实例 + 负载均衡
```

### 5.3 保险配置（面向超大规模）

```zig
// 预留充足的缓冲，避免运行时动态分配
// 对超大规模部署降低风险

pub const MAX_CONNECTIONS = 2_000_000;   // 预期 1M，预留 2 倍
pub const MAX_CLIENTS_POOL = 500_000;    // 预热 25%（偏大以安全）
pub const FORWARD_BATCH_SIZE = 10_000;   // 最优吞吐
pub const DEFAULT_LOG_LEVEL = LogLevel.warn;

// 内存占用：预热 ~5.5GB + 固定 ~200MB = ~5.7GB
// 成本优势：避免动态分配导致的 GC 停顿
```

## 6. 动态调整策略

### 6.1 监控指标和调整

```
监控指标                     阈值      调整方案
─────────────────────────────────────────────────────────
活跃连接 / MAX_CONNECTIONS  > 80%     增加 MAX_CONNECTIONS 或添加实例
活跃连接 / MAX_CLIENTS_POOL < 10%     可能预热过度，下次可减少
内存占用增长率               > 5%/h   检查内存泄漏
CPU 占用（空闲）             > 5%     检查无限循环或日志过多
网络事件响应延迟             > 10ms   可能过载，考虑扩容
缓存命中率                   < 80%    客户端订阅模式不佳
```

### 6.2 逐步增长方案

```
第一阶段：初期部署
- MAX_CONNECTIONS = 10,000
- 观察 1 周，收集监控数据
- 预期连接增长率

第二阶段：中期扩展（连接增长 50-100%）
- 增加 MAX_CONNECTIONS 到 50,000
- 更新预热大小
- 调整系统参数

第三阶段：长期规划（连接增长 100-500%）
- 考虑多机部署
- 使用负载均衡
- 或配置单机 1M 支持

每次调整步骤：
1. 编辑 config.zig
2. zig build -Doptimize=ReleaseFast
3. 灰度发布（先小范围测试）
4. 监控 24 小时
5. 全量上线
```

---

**最后更新**：2025-10-24  
**文档版本**：1.0  
**适用场景**：Zig 0.15.2 MQTT Broker 部署
